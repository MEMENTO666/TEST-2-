<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>mark-40(slide)</title>
</head>
<body>
  <!-- pseudo code build -->
  <!-- 
    pseudo code (의사코드) : 사람이 한번에 알고리즘을 구축하기 어렵기 때문에(전체적인 흐름을 보기위해) 코드 작성하기전 간단한 방법으로 코드의 논리(logic)를 따져보는 준비작업 or 사전작업 -> 점검작업
  -->
  <!-- 
    pseudo 1. 배열(array)가 존재한다.
    pseudo 2. 버튼을 누르면 배열의 원소가 바뀐다.
    ? 배열의 맨 앞의 원소가 맨 마지막 원소로 배치된다.
    ? 배열의 맨 마지막 원소가 맨 첫번째 원소로 배치된다.
    pseudo 3. DOM API(문서)상에서 보여야 한다.
    pseudo 4. click event에 대응되어야 한다.
   -->

  <script>
    function arrHandler(leftButton, rightButton, array, prarentNode, eventType) {
      // 매개변수 설정 : 이벤트가 일어날 요소들을 점쳐본다. 
      // 1. 왼쪽 오른쪽 버튼
      // 2. 해결할 배열
      // 3. DOM API에 설치할 부모요소
      // 4. 이벤트 타입(click)
    }
    arrHandler();
  </script>
</body>
</html>



                              <!-- ********************************** -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!-- pseudo code build -->
  <!-- 
    pseudo code (의사코드) : 사람이 한번에 알고리즘을 구축하기 어렵기 때문에(전체적인 흐름을 보기위해) 코드 작성하기전 간단한 방법으로 코드의 논리(logic)를 따져보는 준비작업 or 사전작업 -> 점검작업
  -->
  <!-- 
    pseudo 1. 배열(array)이 존재한다.
    pseudo 2. 버튼을 누르면 배열의 원소가 바뀐다.
    ? 배열의 맨 앞의 원소가 맨 마지막 원소로 배치된다.
    ? 배열의 맨 마지막 원소가 맨 첫번째 원소로 배치된다.
    pseudo 3. DOM API(문서)상에서 보여야 한다.
    pseudo 4. click event에 대응되어야 한다.
   -->

  <!-- * DOM API markup -->
  <div id="root"></div>

   <button id="left">left</button>
   <button id="right">right</button>

  <script>
    // array literal
    const arr = [1, 2, 3, 4, 5];
    // identifier initialize
    const root = document.getElementById('root');
    const leftButton = document.getElementById('left');
    const rightButton = document.getElementById('right');

    function arrHandler(leftButton, rightButton, array, prarentNode, eventType) {


    }
    arrHandler(leftButton, rightButton, arr, root, "click");
    /* 
    ? 함수화를 시켰을때 다룰 부분에서 작성이 어려운 이유는 "이것이 무엇인지 모르기때문"이다.
    ? 하지만 "확정된 부분이 있다면" 논리적인 고려사항이 매우 간단해진다.
    ? 예를 들면 아래와 같이 사고 할 수 있다.
    ? "어짜피 DOM 에서 가져올 트리거겟지"
    ? "문서에서 가져오든 javascript에서 리터럴로 만든 배열이든 어짜피 배열이겟지"
    ? "붙일 자리는 어짜피 정해져있어"
    ? 등과 같은 생각방식이고 매우 낯설은 방식이다.
    ? 수많은 연습과 노력이 필요하다.
    */



  </script>
</body>
</html>

                        <!-- ************************************************ -->

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
</head>
<body>
<!-- pseudo code build -->
<!-- 
pseudo code (의사코드) : 사람이 한번에 알고리즘을 구축하기 어렵기 때문에(전체적인 흐름을 보기위해) 코드 작성하기전 간단한 방법으로 코드의 논리(logic)를 따져보는 준비작업 or 사전작업 -> 점검작업
-->
<!-- 
pseudo 1. 배열(array)이 존재한다.
pseudo 2. 버튼을 누르면 배열의 원소가 바뀐다.
? 배열의 맨 앞의 원소가 맨 마지막 원소로 배치된다.
? 배열의 맨 마지막 원소가 맨 첫번째 원소로 배치된다.
pseudo 3. DOM API(문서)상에서 보여야 한다.
pseudo 4. click event에 대응되어야 한다.
-->

<!-- * DOM API markup -->
<div id="root">
<button id="left">left</button>
<button id="right">right</button>
</div>


<script>
// array literal
const arr = [1, 2, 3, 4, 5];
// identifier initialize
const root = document.getElementById('root');
const leftButton = document.getElementById('left');
const rightButton = document.getElementById('right');

// root.addEventListener('click', function(event) {
//   let evenTargetIdValue = event.target.id;
//   /*
//   button 두개의 element를 root의 자식으로 구조를 변경 한 후,
//   button 을 클릭했을때의 id값을 가져오는 것으로 논리를 설정했다.



//   */

//   console.log(evenTargetIdValue);
// });




function arrHandler(leftButton, rightButton, array, parentNode, eventType) {
parentNode.addEventListener(eventType, function(event) {
/*
event.target을 사용하여 유연한 버튼 이벤트를 만들기 위해 분기(판단) 시켜주는 이벤트를 설치했다.
떠오른 만큼의 판단하는 과정이 있었고, 이벤트 발생 주체인 root도 이벤트가 발생하는 것을 발견하여
세번째 if문으로 이를 처리했다.

*/
let eventTargetIdValue = event.target.id;
console.log(eventTargetIdValue);
if(eventTargetIdValue === leftButton) {
console.log(`당신은 지금 ${leftButton} 라는 id값을 가지고 있는 요소를 선택했습니다.`);
}
if(eventTargetIdValue === rightButton) {
console.log(`당신은 지금 ${rightButton} 라는 id값을 가지고 있는 요소를 선택했습니다.`);
}
if(eventTargetIdValue === parentNode.id) {
console.log(`지금 선택한 것 은 컨테이너 ${parentNode.id}의 id 값입니다.`);
}
});


}
arrHandler("left", "right", arr, root, "click");


</script>
</body>
</html>

                    <!-- **************************************** -->

<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
</head>

<body>
<!-- pseudo code build -->
<!-- 
pseudo code (의사코드) : 사람이 한번에 알고리즘을 구축하기 어렵기 때문에(전체적인 흐름을 보기위해) 코드 작성하기전 간단한 방법으로 코드의 논리(logic)를 따져보는 준비작업 or 사전작업 -> 점검작업
-->
<!-- 
pseudo 1. 배열(array)이 존재한다.
pseudo 2. 버튼을 누르면 배열의 원소가 바뀐다.
? 배열의 맨 앞의 원소가 맨 마지막 원소로 배치된다.
? 배열의 맨 마지막 원소가 맨 첫번째 원소로 배치된다.
pseudo 3. DOM API(문서)상에서 보여야 한다.
pseudo 4. click event에 대응되어야 한다.
-->

<!-- * DOM API markup -->
<div id="root">
<button id="left">left</button>
<button id="right">right</button>
</div>


<script>
// array literal
const arr = [1, 2, 3, 4, 5];
// identifier initialize
const root = document.getElementById('root');
const leftButton = document.getElementById('left');
const rightButton = document.getElementById('right');


function arrHandler(leftButton, rightButton, array, parentNode, eventType) {
parentNode.addEventListener(eventType, function (event) {
let eventTargetIdValue = event.target.id;
let temp; // 잠시 데이터를 저장할 임시 배열 핸들링용 변수를 만든다.

const changeArrayIndex = (eventTarget) => {
if (eventTarget === leftButton) {
temp = array[0]; // 배열의 첫번째 요소를 임시변수 temp에 저장한다.
array.shift(); // 배열의 첫번째 요소, 즉 0번째 요소를 삭제한다.
array.push(temp); // 미리 임시변수에 저장해 두었던 배열의 첫번째 원소값 "이었었던" 데이터를 배열 마지막 원소로 추가한다.
console.log(array);
}
if (eventTarget === rightButton) {
temp = array[array.length - 1]; // 배열의 마지막 요소를 임시변수 temp에 저장한다.
// arr.length(배열의 길이값)은 항상 배열의 마지막 원소의 인덱스값보다 정수 1이 높기 때문에 길이값에서 -1을 하면 마지막원소를 언제든지 구할 수 있다.
array.pop(); // 배열의 맨 마지막 원소를 삭제한다.
array.unshift(temp); // 배열의 맨 앞 요소에 임시로 저장해둔 '마지막 원소값 이었었던' 데이터를 배열 첫번째 요소로 추가한다.
console.log(array);
}
}


console.log(eventTargetIdValue);
if (eventTargetIdValue === leftButton) {
// console.log(`당신은 지금 ${leftButton} 라는 id값을 가지고 있는 요소를 선택했습니다.`);
temp = array[0]; // 배열의 첫번째 요소를 임시변수 temp에 저장한다.
array.shift(); // 배열의 첫번째 요소, 즉 0번째 요소를 삭제한다.
array.push(temp); // 미리 임시변수에 저장해 두었던 배열의 첫번째 원소값 "이었었던" 데이터를 배열 마지막 원소로 추가한다.
console.log(array);
}
if (eventTargetIdValue === rightButton) {
// console.log(`당신은 지금 ${rightButton} 라는 id값을 가지고 있는 요소를 선택했습니다.`);
temp = array[array.length - 1]; // 배열의 마지막 요소를 임시변수 temp에 저장한다.
// arr.length(배열의 길이값)은 항상 배열의 마지막 원소의 인덱스값보다 정수 1이 높기 때문에 길이값에서 -1을 하면 마지막원소를 언제든지 구할 수 있다.
array.pop(); // 배열의 맨 마지막 원소를 삭제한다.
array.unshift(temp); // 배열의 맨 앞 요소에 임시로 저장해둔 '마지막 원소값 이었었던' 데이터를 배열 첫번째 요소로 추가한다.
console.log(array);

}
if (eventTargetIdValue === parentNode.id) {
console.log(`지금 선택한 것 은 컨테이너 ${parentNode.id}의 id 값입니다.`);
}
});


}
arrHandler("left", "right", arr, root, "click");
</script>
</body>

</html>


                      <!-- ******************************************** -->
<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
</head>

<body>

<div id="root">
<!-- * 문서에 새길 div 추가 -->
<div id="inject-value"></div>
<button id="left">left</button>
<button id="right">right</button>
</div>


<script>
// array literal
const arr = [1, 2, 3, 4, 5];
// identifier initialize
const root = document.getElementById('root');
const injectValue = document.getElementById('inject-value');
const leftButton = document.getElementById('left');
const rightButton = document.getElementById('right');


function arrHandler(leftButton, rightButton, array, parentNode, appendNode, eventType) {
parentNode.addEventListener(eventType, function (event) {
let eventTargetIdValue = event.target.id;
let temp;

const changeArrayIndex = (eventTarget) => {
if (eventTarget === leftButton) {
temp = array[0];
array.shift();
array.push(temp);
console.log(array);
elementRemover();
elementAppender();
elementStyler();
}
if (eventTarget === rightButton) {
temp = array[array.length - 1];
array.pop();
array.unshift(temp);
console.log(array);
elementRemover();
elementAppender();
elementStyler();
}
}

const elementRemover = () => {
while(injectValue.firstChild) {

injectValue.removeChild(injectValue.firstChild);
}
}
const elementAppender = () => {
array.forEach(element => {
const span = document.createElement('span');
span.textContent = element;
appendNode.appendChild(span);
});
}
const elementStyler = () => {
injectValue.firstChild.style.fontSize = "2rem";
}


changeArrayIndex(eventTargetIdValue);



if (eventTargetIdValue === parentNode.id) {
console.log(`지금 선택한 것 은 컨테이너 ${parentNode.id}의 id 값입니다.`);
}
});

}
arrHandler("left", "right", arr, root, injectValue, "click");

/*
함수의 구조 설명
1. arrHandler() 라는 함수를 '선언' 하여 인터렉션에 필요한 요소들을 매개변수로 처리할 준비를 했다.
2. 주요 처리 목표인 '배열'을 핸들링하기 위해 changeArrayIndex()라는 함수를 '내부함수' 용으로 만들었다.
3. 메인함수인 arrHandler()의 매개변수를 활용, if()문으로 경우의 수를 분기(분별하여 작동하도록)했다.
4. 3종의 세부 '동작용' 작은 함수들을 판단하는 '내부함수' changeArrayIndex() 함수에 순차적으로 실행시키도록 조정했다.
※ 고차함수(higher order function)를 구축하는 방식을 설명하기 위해 불필요한 함수 남용과 유연한판단을 하지 않는 패턴이기때문에 위의 예제는 '좋은코드' 라고 보기는 어렵고, '읽히게'하기 위한 용도라고 볼 수 있으며,
여러가지 접근방식으로 코드양을 줄이거나, 혹은 유연한 방식으로 개조할 수 있다.
※ 유연함을 만들고자 한다면,
1. 타입체크 기능을 넣어 함수가 오작동하지 않도록 해야한다.
2. 배열을 리터럴로 작성했기 때문에 -> 문서의 유사배열(HTMLCollection, NodeList등)을 배열로 가공하는 기능을 넣어야 한다.
3. 매개변수가 여섯개나 되기때문에 작성용으로 불편하다. -> 매개변수 타입을 객체나 기타 등등으로 가공한다면 훨씬더 편리하게 함수를 호출 할 수 있다.
※ 코드양을 줄일 것이라면(혹은 직관적으로 만들 것이라면),
1. 판단기준 다르게 할 수도 있을 것 -> 연구의 영역
2. 예외처리(Exception handle) 과 같은 방식을 차용하면 훨씬 더 직관적으로 코드를 작성 할 수 있다.
3. 위의 작업은 동기(synchronous)처리 방식이므로 다방면의 연구로 '복잡도'를 낮출 수 있다.
*/




</script>
</body>

</html>